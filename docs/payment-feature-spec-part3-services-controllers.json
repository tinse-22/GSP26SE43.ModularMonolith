{
  "$schema": "payment-feature-specification",
  "version": "2.0.0",
  "title": "ClassifiedAds.ModularMonolith Payment Feature - Commands, Queries, Services & Controller",
  "part": "3/3 - CQRS Commands, Queries, PayOS Service & PaymentsController",

  "payOsService": {
    "interface": {
      "file": "ClassifiedAds.Modules.Subscription/Services/IPayOsService.cs",
      "description": "Interface cho PayOS service - chỉ xử lý external API calls, KHÔNG chứa business logic",
      "code": "using ClassifiedAds.Modules.Subscription.Models;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Services;\n\npublic interface IPayOsService\n{\n    /// <summary>Tạo payment link qua PayOS API v2.</summary>\n    Task<string> CreatePaymentLinkAsync(PayOsCreatePaymentRequest request, CancellationToken ct = default);\n\n    /// <summary>Xác minh webhook signature (HMAC-SHA256).</summary>\n    bool VerifyWebhookSignature(PayOsWebhookPayload payload, string rawBody);\n\n    /// <summary>Lấy thông tin payment từ PayOS (dùng cho debug/sync).</summary>\n    Task<PayOsGetPaymentData> GetPaymentInfoAsync(long orderCode, CancellationToken ct = default);\n}"
    },
    "implementation": {
      "file": "ClassifiedAds.Modules.Subscription/Services/PayOsService.cs",
      "description": "PayOS gateway integration - typed HttpClient, HMAC-SHA256 signature, API v2",
      "dependencies": [
        "HttpClient (typed, injected via AddHttpClient<IPayOsService, PayOsService>())",
        "IOptions<PayOsOptions>",
        "ILogger<PayOsService>"
      ],
      "code": "using ClassifiedAds.CrossCuttingConcerns.Exceptions;\nusing ClassifiedAds.Modules.Subscription.ConfigurationOptions;\nusing ClassifiedAds.Modules.Subscription.Models;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Json;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Services;\n\npublic class PayOsService : IPayOsService\n{\n    private readonly HttpClient _httpClient;\n    private readonly PayOsOptions _options;\n    private readonly ILogger<PayOsService> _logger;\n\n    public PayOsService(\n        HttpClient httpClient,\n        IOptions<PayOsOptions> options,\n        ILogger<PayOsService> logger)\n    {\n        _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));\n        _options = options?.Value ?? throw new ArgumentNullException(nameof(options));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    public async Task<string> CreatePaymentLinkAsync(PayOsCreatePaymentRequest req, CancellationToken ct = default)\n    {\n        ArgumentNullException.ThrowIfNull(req);\n\n        var returnUrl = string.IsNullOrWhiteSpace(req.ReturnUrl) ? _options.ReturnUrl : req.ReturnUrl;\n        var cancelUrl = string.IsNullOrWhiteSpace(req.CancelUrl) ? (_options.CancelUrl ?? returnUrl) : req.CancelUrl;\n        var description = req.Description ?? string.Empty;\n\n        // Build HMAC-SHA256 signature for PayOS\n        var signatureData = $\"amount={req.Amount}&cancelUrl={cancelUrl}&description={description}&orderCode={req.OrderCode}&returnUrl={returnUrl}\";\n        var signature = ComputeHmacSha256(signatureData, _options.SecretKey);\n\n        var payload = new\n        {\n            orderCode = req.OrderCode,\n            amount = req.Amount,\n            description,\n            returnUrl,\n            cancelUrl,\n            buyerName = req.BuyerName,\n            buyerEmail = req.BuyerEmail,\n            buyerPhone = req.BuyerPhone,\n            signature,\n        };\n\n        var endpoint = $\"{_options.BaseUrl.TrimEnd('/')}/v2/payment-requests\";\n        using var request = new HttpRequestMessage(HttpMethod.Post, endpoint)\n        {\n            Content = JsonContent.Create(payload),\n        };\n        request.Headers.TryAddWithoutValidation(\"x-client-id\", _options.ClientId);\n        request.Headers.TryAddWithoutValidation(\"x-api-key\", _options.ApiKey);\n\n        var response = await _httpClient.SendAsync(request, ct).ConfigureAwait(false);\n        var body = await response.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n        if (!response.IsSuccessStatusCode)\n        {\n            _logger.LogError(\"PayOS CreatePaymentLink failed. Status={Status}, Body={Body}\", response.StatusCode, body);\n            throw new ValidationException($\"Failed to create PayOS payment link. Status: {response.StatusCode}\");\n        }\n\n        var parsed = JsonSerializer.Deserialize<PayOsPaymentResponse>(body, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n        if (parsed is null || !string.Equals(parsed.Code, \"00\", StringComparison.OrdinalIgnoreCase))\n        {\n            throw new ValidationException($\"PayOS error: {parsed?.Desc ?? \"Unknown\"}\");\n        }\n\n        var checkoutUrl = parsed.Data?.CheckoutUrl;\n        if (string.IsNullOrWhiteSpace(checkoutUrl))\n        {\n            throw new ValidationException(\"PayOS response missing checkout URL.\");\n        }\n\n        return checkoutUrl;\n    }\n\n    public bool VerifyWebhookSignature(PayOsWebhookPayload payload, string rawBody)\n    {\n        if (payload?.Data is null || string.IsNullOrWhiteSpace(payload.Signature))\n        {\n            return false;\n        }\n\n        if (string.IsNullOrWhiteSpace(_options.SecretKey))\n        {\n            return false;\n        }\n\n        using var doc = JsonDocument.Parse(rawBody);\n        if (!doc.RootElement.TryGetProperty(\"data\", out var dataElement))\n        {\n            return false;\n        }\n\n        var dataDict = JsonSerializer.Deserialize<System.Collections.Generic.Dictionary<string, JsonElement>>(dataElement.GetRawText());\n        if (dataDict == null)\n        {\n            return false;\n        }\n\n        var sortedPairs = dataDict\n            .OrderBy(kv => kv.Key, StringComparer.Ordinal)\n            .Select(kv => $\"{kv.Key}={NormalizeValue(kv.Value)}\");\n        var sortedData = string.Join(\"&\", sortedPairs);\n\n        var expectedSignature = ComputeHmacSha256(sortedData, _options.SecretKey);\n        return string.Equals(expectedSignature, payload.Signature, StringComparison.OrdinalIgnoreCase);\n    }\n\n    public async Task<PayOsGetPaymentData> GetPaymentInfoAsync(long orderCode, CancellationToken ct = default)\n    {\n        var endpoint = $\"{_options.BaseUrl.TrimEnd('/')}/v2/payment-requests/{orderCode}\";\n        using var request = new HttpRequestMessage(HttpMethod.Get, endpoint);\n        request.Headers.TryAddWithoutValidation(\"x-client-id\", _options.ClientId);\n        request.Headers.TryAddWithoutValidation(\"x-api-key\", _options.ApiKey);\n\n        var response = await _httpClient.SendAsync(request, ct).ConfigureAwait(false);\n        var body = await response.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n        if (!response.IsSuccessStatusCode)\n        {\n            throw new ValidationException($\"Failed to get PayOS payment info. Status: {response.StatusCode}\");\n        }\n\n        var parsed = JsonSerializer.Deserialize<PayOsGetPaymentResponse>(body, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n        if (parsed?.Data is null)\n        {\n            throw new ValidationException(\"PayOS response missing data.\");\n        }\n\n        return parsed.Data;\n    }\n\n    private static string ComputeHmacSha256(string data, string secret)\n    {\n        using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(secret));\n        var hash = hmac.ComputeHash(Encoding.UTF8.GetBytes(data));\n        return BitConverter.ToString(hash).Replace(\"-\", \"\").ToLowerInvariant();\n    }\n\n    private static string NormalizeValue(JsonElement element)\n    {\n        return element.ValueKind switch\n        {\n            JsonValueKind.Null => string.Empty,\n            JsonValueKind.String => element.GetString() ?? string.Empty,\n            JsonValueKind.Number => element.GetRawText(),\n            JsonValueKind.True => \"true\",\n            JsonValueKind.False => \"false\",\n            _ => element.GetRawText(),\n        };\n    }\n}",
      "payOsApiDetails": {
        "createPaymentLink": {
          "endpoint": "POST {BaseUrl}/v2/payment-requests",
          "headers": {
            "x-client-id": "PayOsOptions.ClientId",
            "x-api-key": "PayOsOptions.ApiKey"
          },
          "signatureComputation": "data = 'amount={amount}&cancelUrl={cancelUrl}&description={desc}&orderCode={orderCode}&returnUrl={returnUrl}'; signature = HMAC-SHA256(data, SecretKey).ToHexLower()",
          "successCode": "response.code == '00'"
        },
        "getPaymentInfo": {
          "endpoint": "GET {BaseUrl}/v2/payment-requests/{orderCode}",
          "headers": { "x-client-id": "ClientId", "x-api-key": "ApiKey" },
          "description": "Dùng cho debug/sync khi webhook thất bại"
        },
        "webhookSignatureVerification": {
          "algorithm": [
            "1. Parse 'data' object từ raw JSON body",
            "2. Sort tất cả key-value pairs theo alphabet",
            "3. Join thành 'key1=value1&key2=value2&...'",
            "4. Compute HMAC-SHA256 với SecretKey",
            "5. So sánh hex string với payload.Signature (case-insensitive)"
          ]
        }
      }
    }
  },

  "commands": {
    "CreateSubscriptionPaymentCommand": {
      "file": "ClassifiedAds.Modules.Subscription/Commands/CreateSubscriptionPaymentCommand.cs",
      "description": "Command tạo payment intent cho mua/upgrade subscription. Handler chứa toàn bộ business logic.",
      "code": "using ClassifiedAds.Application;\nusing ClassifiedAds.CrossCuttingConcerns.Exceptions;\nusing ClassifiedAds.Domain.Repositories;\nusing ClassifiedAds.Modules.Subscription.Entities;\nusing ClassifiedAds.Modules.Subscription.Models;\nusing ClassifiedAds.Modules.Subscription.ConfigurationOptions;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Commands;\n\npublic class CreateSubscriptionPaymentCommand : ICommand\n{\n    public Guid UserId { get; set; }\n\n    public Guid PlanId { get; set; }\n\n    public CreateSubscriptionPaymentModel Model { get; set; }\n\n    // Output\n    public SubscriptionPurchaseResultModel Result { get; set; }\n}\n\npublic class CreateSubscriptionPaymentCommandHandler : ICommandHandler<CreateSubscriptionPaymentCommand>\n{\n    private readonly IRepository<SubscriptionPlan, Guid> _planRepository;\n    private readonly IRepository<UserSubscription, Guid> _subscriptionRepository;\n    private readonly IRepository<SubscriptionHistory, Guid> _historyRepository;\n    private readonly IRepository<PaymentIntent, Guid> _paymentIntentRepository;\n    private readonly PayOsOptions _payOsOptions;\n\n    public CreateSubscriptionPaymentCommandHandler(\n        IRepository<SubscriptionPlan, Guid> planRepository,\n        IRepository<UserSubscription, Guid> subscriptionRepository,\n        IRepository<SubscriptionHistory, Guid> historyRepository,\n        IRepository<PaymentIntent, Guid> paymentIntentRepository,\n        IOptions<PayOsOptions> payOsOptions)\n    {\n        _planRepository = planRepository;\n        _subscriptionRepository = subscriptionRepository;\n        _historyRepository = historyRepository;\n        _paymentIntentRepository = paymentIntentRepository;\n        _payOsOptions = payOsOptions?.Value ?? new PayOsOptions();\n    }\n\n    public async Task HandleAsync(CreateSubscriptionPaymentCommand command, CancellationToken cancellationToken = default)\n    {\n        // 1. Validate plan\n        var plan = await _planRepository.FirstOrDefaultAsync(\n            _planRepository.GetQueryableSet().Where(x => x.Id == command.PlanId));\n\n        if (plan == null)\n        {\n            throw new NotFoundException($\"Subscription plan '{command.PlanId}' was not found.\");\n        }\n\n        if (!plan.IsActive)\n        {\n            throw new ValidationException(\"Subscription plan is inactive.\");\n        }\n\n        // 2. Determine price based on billing cycle\n        var billingCycle = command.Model?.BillingCycle ?? BillingCycle.Monthly;\n        var price = billingCycle == BillingCycle.Yearly ? plan.PriceYearly : plan.PriceMonthly;\n\n        if (price is null)\n        {\n            throw new ValidationException($\"Plan '{plan.Name}' does not support {billingCycle} billing.\");\n        }\n\n        // 3. Check existing subscription\n        var existingSubscription = await _subscriptionRepository.FirstOrDefaultAsync(\n            _subscriptionRepository.GetQueryableSet()\n                .Where(x => x.UserId == command.UserId\n                    && (x.Status == SubscriptionStatus.Active || x.Status == SubscriptionStatus.Trial)));\n\n        // 4. Free plan → activate immediately\n        if (price <= 0)\n        {\n            await _planRepository.UnitOfWork.ExecuteInTransactionAsync(async ct =>\n            {\n                var subscription = CreateSubscription(command.UserId, plan, billingCycle, existingSubscription);\n\n                if (existingSubscription != null)\n                {\n                    await _subscriptionRepository.UpdateAsync(existingSubscription, ct);\n                }\n                else\n                {\n                    await _subscriptionRepository.AddAsync(subscription, ct);\n                }\n\n                var history = CreateHistory(subscription, existingSubscription, ChangeType.Created);\n                await _historyRepository.AddAsync(history, ct);\n                await _planRepository.UnitOfWork.SaveChangesAsync(ct);\n\n                command.Result = new SubscriptionPurchaseResultModel\n                {\n                    RequiresPayment = false,\n                    Subscription = await GetSubscriptionModel(subscription.Id, ct),\n                };\n            }, cancellationToken: cancellationToken);\n\n            return;\n        }\n\n        // 5. Paid plan → create PaymentIntent\n        var purpose = existingSubscription != null\n            ? PaymentPurpose.SubscriptionUpgrade\n            : PaymentPurpose.SubscriptionPurchase;\n\n        await _planRepository.UnitOfWork.ExecuteInTransactionAsync(async ct =>\n        {\n            var paymentIntent = new PaymentIntent\n            {\n                Id = Guid.NewGuid(),\n                UserId = command.UserId,\n                Amount = price.Value,\n                Currency = plan.Currency ?? \"VND\",\n                Purpose = purpose,\n                PlanId = plan.Id,\n                BillingCycle = billingCycle,\n                SubscriptionId = existingSubscription?.Id,\n                Status = PaymentIntentStatus.RequiresPayment,\n                ExpiresAt = DateTimeOffset.UtcNow.AddMinutes(_payOsOptions.IntentExpirationMinutes),\n            };\n\n            await _paymentIntentRepository.AddAsync(paymentIntent, ct);\n            await _planRepository.UnitOfWork.SaveChangesAsync(ct);\n\n            command.Result = new SubscriptionPurchaseResultModel\n            {\n                RequiresPayment = true,\n                PaymentIntentId = paymentIntent.Id,\n            };\n        }, cancellationToken: cancellationToken);\n    }\n\n    private static UserSubscription CreateSubscription(Guid userId, SubscriptionPlan plan, BillingCycle cycle, UserSubscription existing)\n    {\n        var now = DateOnly.FromDateTime(DateTime.UtcNow);\n        var endDate = cycle == BillingCycle.Yearly ? now.AddYears(1) : now.AddMonths(1);\n\n        if (existing != null)\n        {\n            existing.PlanId = plan.Id;\n            existing.BillingCycle = cycle;\n            existing.Status = SubscriptionStatus.Active;\n            existing.StartDate = now;\n            existing.EndDate = plan.PriceMonthly > 0 || plan.PriceYearly > 0 ? endDate : null;\n            existing.NextBillingDate = plan.PriceMonthly > 0 || plan.PriceYearly > 0 ? endDate : null;\n            return existing;\n        }\n\n        return new UserSubscription\n        {\n            Id = Guid.NewGuid(),\n            UserId = userId,\n            PlanId = plan.Id,\n            Status = SubscriptionStatus.Active,\n            BillingCycle = cycle,\n            StartDate = now,\n            EndDate = plan.PriceMonthly > 0 || plan.PriceYearly > 0 ? endDate : null,\n            NextBillingDate = plan.PriceMonthly > 0 || plan.PriceYearly > 0 ? endDate : null,\n            AutoRenew = true,\n        };\n    }\n\n    private static SubscriptionHistory CreateHistory(UserSubscription sub, UserSubscription old, ChangeType type)\n    {\n        return new SubscriptionHistory\n        {\n            Id = Guid.NewGuid(),\n            SubscriptionId = sub.Id,\n            OldPlanId = old?.PlanId,\n            NewPlanId = sub.PlanId,\n            ChangeType = type,\n            ChangeReason = type.ToString(),\n            EffectiveDate = DateOnly.FromDateTime(DateTime.UtcNow),\n        };\n    }\n\n    private async Task<SubscriptionModel> GetSubscriptionModel(Guid id, CancellationToken ct)\n    {\n        // Query subscription with plan info for the response model\n        // Note: This is simplified - actual implementation should use mapping\n        return null; // Will be populated by the calling controller via a Query\n    }\n}"
    },

    "CreatePayOsCheckoutCommand": {
      "file": "ClassifiedAds.Modules.Subscription/Commands/CreatePayOsCheckoutCommand.cs",
      "description": "Command tạo PayOS checkout URL cho PaymentIntent đang pending",
      "code": "using ClassifiedAds.Application;\nusing ClassifiedAds.CrossCuttingConcerns.Exceptions;\nusing ClassifiedAds.Domain.Repositories;\nusing ClassifiedAds.Modules.Subscription.Entities;\nusing ClassifiedAds.Modules.Subscription.Models;\nusing ClassifiedAds.Modules.Subscription.Services;\nusing ClassifiedAds.Modules.Subscription.ConfigurationOptions;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Commands;\n\npublic class CreatePayOsCheckoutCommand : ICommand\n{\n    public Guid UserId { get; set; }\n\n    public Guid IntentId { get; set; }\n\n    public string ReturnUrl { get; set; }\n\n    // Output\n    public PayOsCheckoutResponseModel Result { get; set; }\n}\n\npublic class CreatePayOsCheckoutCommandHandler : ICommandHandler<CreatePayOsCheckoutCommand>\n{\n    private readonly IRepository<PaymentIntent, Guid> _paymentIntentRepository;\n    private readonly IRepository<SubscriptionPlan, Guid> _planRepository;\n    private readonly IPayOsService _payOsService;\n    private readonly PayOsOptions _payOsOptions;\n\n    public CreatePayOsCheckoutCommandHandler(\n        IRepository<PaymentIntent, Guid> paymentIntentRepository,\n        IRepository<SubscriptionPlan, Guid> planRepository,\n        IPayOsService payOsService,\n        IOptions<PayOsOptions> payOsOptions)\n    {\n        _paymentIntentRepository = paymentIntentRepository;\n        _planRepository = planRepository;\n        _payOsService = payOsService;\n        _payOsOptions = payOsOptions?.Value ?? new PayOsOptions();\n    }\n\n    public async Task HandleAsync(CreatePayOsCheckoutCommand command, CancellationToken cancellationToken = default)\n    {\n        var pi = await _paymentIntentRepository.FirstOrDefaultAsync(\n            _paymentIntentRepository.GetQueryableSet().Where(x => x.Id == command.IntentId));\n\n        if (pi == null)\n        {\n            throw new NotFoundException($\"Payment intent '{command.IntentId}' was not found.\");\n        }\n\n        if (pi.UserId != command.UserId)\n        {\n            throw new ValidationException(\"Payment intent does not belong to the user.\");\n        }\n\n        if (pi.Status != PaymentIntentStatus.RequiresPayment)\n        {\n            throw new ValidationException($\"Payment intent is not in RequiresPayment status. Current: {pi.Status}\");\n        }\n\n        if (pi.ExpiresAt <= DateTimeOffset.UtcNow)\n        {\n            throw new ValidationException(\"Payment intent has expired.\");\n        }\n\n        // Generate or reuse OrderCode\n        var orderCode = pi.OrderCode ?? NewOrderCode();\n\n        // Build description (PayOS max 25 chars)\n        var plan = await _planRepository.FirstOrDefaultAsync(\n            _planRepository.GetQueryableSet().Where(x => x.Id == pi.PlanId));\n        var planName = plan?.Name ?? \"Plan\";\n        var description = $\"{planName}#{orderCode % 1000000}\";\n        if (description.Length > 25)\n        {\n            description = description[..25];\n        }\n\n        // Resolve URLs\n        var returnUrl = !string.IsNullOrWhiteSpace(command.ReturnUrl)\n            ? command.ReturnUrl\n            : _payOsOptions.ReturnUrl;\n        var cancelUrl = _payOsOptions.CancelUrl ?? returnUrl;\n\n        // Convert decimal amount to long (PayOS expects integer amount in VND)\n        var amountLong = (long)Math.Ceiling(pi.Amount);\n\n        var request = new PayOsCreatePaymentRequest\n        {\n            OrderCode = orderCode,\n            Amount = amountLong,\n            Description = description,\n            ReturnUrl = returnUrl,\n            CancelUrl = cancelUrl,\n        };\n\n        var checkoutUrl = await _payOsService.CreatePaymentLinkAsync(request, cancellationToken);\n\n        // Update PaymentIntent with checkout info\n        await _paymentIntentRepository.UnitOfWork.ExecuteInTransactionAsync(async ct =>\n        {\n            pi.OrderCode = orderCode;\n            pi.CheckoutUrl = checkoutUrl;\n            await _paymentIntentRepository.UpdateAsync(pi, ct);\n            await _paymentIntentRepository.UnitOfWork.SaveChangesAsync(ct);\n        }, cancellationToken: cancellationToken);\n\n        command.Result = new PayOsCheckoutResponseModel\n        {\n            CheckoutUrl = checkoutUrl,\n            OrderCode = orderCode,\n        };\n    }\n\n    /// <summary>\n    /// Generate 15-digit unique order code for PayOS.\n    /// Algorithm: UnixTimeMillis % 10^12 * 1000 + random(100-999)\n    /// </summary>\n    private static long NewOrderCode()\n    {\n        var ms = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() % 1_000_000_000_000L;\n        var rnd = RandomNumberGenerator.GetInt32(100, 1000);\n        return ms * 1000 + rnd;\n    }\n}"
    },

    "HandlePayOsWebhookCommand": {
      "file": "ClassifiedAds.Modules.Subscription/Commands/HandlePayOsWebhookCommand.cs",
      "description": "Command xử lý webhook từ PayOS - xác minh signature, tạo transaction, kích hoạt subscription",
      "code": "using ClassifiedAds.Application;\nusing ClassifiedAds.CrossCuttingConcerns.Exceptions;\nusing ClassifiedAds.Domain.Repositories;\nusing ClassifiedAds.Modules.Subscription.Entities;\nusing ClassifiedAds.Modules.Subscription.Models;\nusing ClassifiedAds.Modules.Subscription.Services;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Commands;\n\npublic class HandlePayOsWebhookCommand : ICommand\n{\n    public PayOsWebhookPayload Payload { get; set; }\n\n    public string RawBody { get; set; }\n\n    public string SignatureHeader { get; set; }\n\n    // Output\n    public PayOsWebhookOutcome Outcome { get; set; }\n}\n\npublic class HandlePayOsWebhookCommandHandler : ICommandHandler<HandlePayOsWebhookCommand>\n{\n    private const string ProviderName = \"PAYOS\";\n    private readonly IRepository<PaymentIntent, Guid> _paymentIntentRepository;\n    private readonly IRepository<PaymentTransaction, Guid> _paymentTransactionRepository;\n    private readonly IRepository<UserSubscription, Guid> _subscriptionRepository;\n    private readonly IRepository<SubscriptionPlan, Guid> _planRepository;\n    private readonly IRepository<SubscriptionHistory, Guid> _historyRepository;\n    private readonly IPayOsService _payOsService;\n    private readonly ILogger<HandlePayOsWebhookCommandHandler> _logger;\n\n    public HandlePayOsWebhookCommandHandler(\n        IRepository<PaymentIntent, Guid> paymentIntentRepository,\n        IRepository<PaymentTransaction, Guid> paymentTransactionRepository,\n        IRepository<UserSubscription, Guid> subscriptionRepository,\n        IRepository<SubscriptionPlan, Guid> planRepository,\n        IRepository<SubscriptionHistory, Guid> historyRepository,\n        IPayOsService payOsService,\n        ILogger<HandlePayOsWebhookCommandHandler> logger)\n    {\n        _paymentIntentRepository = paymentIntentRepository;\n        _paymentTransactionRepository = paymentTransactionRepository;\n        _subscriptionRepository = subscriptionRepository;\n        _planRepository = planRepository;\n        _historyRepository = historyRepository;\n        _payOsService = payOsService;\n        _logger = logger;\n    }\n\n    public async Task HandleAsync(HandlePayOsWebhookCommand command, CancellationToken cancellationToken = default)\n    {\n        var payload = command.Payload;\n        var isManualSync = string.Equals(payload.Signature, \"manual-sync\", StringComparison.OrdinalIgnoreCase);\n\n        // 1. Verify signature\n        if (!isManualSync && !_payOsService.VerifyWebhookSignature(payload, command.RawBody))\n        {\n            throw new ValidationException(\"Invalid webhook signature.\");\n        }\n\n        if (payload.Data is null)\n        {\n            throw new ValidationException(\"Webhook missing data.\");\n        }\n\n        var orderCode = payload.Data.OrderCode;\n        if (orderCode <= 0)\n        {\n            throw new ValidationException(\"Invalid order code.\");\n        }\n\n        // 2. Find PaymentIntent by OrderCode\n        var pi = await _paymentIntentRepository.FirstOrDefaultAsync(\n            _paymentIntentRepository.GetQueryableSet().Where(x => x.OrderCode == orderCode));\n\n        if (pi == null)\n        {\n            _logger.LogWarning(\"PayOS webhook: Unknown order code {OrderCode}, ignoring.\", orderCode);\n            command.Outcome = PayOsWebhookOutcome.Ignored;\n            return;\n        }\n\n        // 3. Determine if payment was successful\n        var isPaid = payload.Success && string.Equals(payload.Code, \"00\", StringComparison.OrdinalIgnoreCase);\n        var providerRef = payload.Data.Reference ?? payload.Data.PaymentLinkId ?? orderCode.ToString();\n\n        // 4. Handle failed/canceled payment\n        if (!isPaid)\n        {\n            if (pi.Status != PaymentIntentStatus.Canceled && pi.Status != PaymentIntentStatus.Succeeded)\n            {\n                pi.Status = PaymentIntentStatus.Canceled;\n                await _paymentIntentRepository.UpdateAsync(pi, cancellationToken);\n                await _paymentIntentRepository.UnitOfWork.SaveChangesAsync(cancellationToken);\n            }\n\n            command.Outcome = PayOsWebhookOutcome.Processed;\n            return;\n        }\n\n        // 5. Idempotency check - transaction already exists?\n        var existingTx = await _paymentTransactionRepository.FirstOrDefaultAsync(\n            _paymentTransactionRepository.GetQueryableSet()\n                .Where(x => x.Provider == ProviderName && x.ProviderRef == providerRef));\n\n        if (existingTx != null)\n        {\n            _logger.LogInformation(\"PayOS webhook: Transaction already exists for ProviderRef={ProviderRef}, idempotent success.\", providerRef);\n\n            if (pi.Status != PaymentIntentStatus.Succeeded)\n            {\n                pi.Status = PaymentIntentStatus.Succeeded;\n                await _paymentIntentRepository.UpdateAsync(pi, cancellationToken);\n                await _paymentIntentRepository.UnitOfWork.SaveChangesAsync(cancellationToken);\n            }\n\n            command.Outcome = PayOsWebhookOutcome.Processed;\n            return;\n        }\n\n        // 6. Process payment within transaction\n        await _paymentIntentRepository.UnitOfWork.ExecuteInTransactionAsync(async ct =>\n        {\n            // Create/update subscription\n            var subscription = await ActivateSubscription(pi, ct);\n\n            // Create payment transaction record\n            var transaction = new PaymentTransaction\n            {\n                Id = Guid.NewGuid(),\n                UserId = pi.UserId,\n                SubscriptionId = subscription.Id,\n                PaymentIntentId = pi.Id,\n                Amount = pi.Amount,\n                Currency = pi.Currency,\n                Status = PaymentStatus.Succeeded,\n                PaymentMethod = \"bank_transfer\",\n                Provider = ProviderName,\n                ProviderRef = providerRef,\n                ExternalTxnId = providerRef,\n            };\n\n            await _paymentTransactionRepository.AddAsync(transaction, ct);\n\n            // Update PaymentIntent status\n            pi.Status = PaymentIntentStatus.Succeeded;\n            await _paymentIntentRepository.UpdateAsync(pi, ct);\n\n            await _paymentIntentRepository.UnitOfWork.SaveChangesAsync(ct);\n        }, cancellationToken: cancellationToken);\n\n        command.Outcome = PayOsWebhookOutcome.Processed;\n    }\n\n    private async Task<UserSubscription> ActivateSubscription(PaymentIntent pi, CancellationToken ct)\n    {\n        var plan = await _planRepository.FirstOrDefaultAsync(\n            _planRepository.GetQueryableSet().Where(x => x.Id == pi.PlanId));\n\n        if (plan == null)\n        {\n            throw new NotFoundException($\"Subscription plan '{pi.PlanId}' was not found.\");\n        }\n\n        var now = DateOnly.FromDateTime(DateTime.UtcNow);\n        var endDate = pi.BillingCycle == BillingCycle.Yearly ? now.AddYears(1) : now.AddMonths(1);\n\n        UserSubscription subscription;\n        ChangeType changeType;\n\n        if (pi.SubscriptionId.HasValue)\n        {\n            // Upgrade existing subscription\n            subscription = await _subscriptionRepository.FirstOrDefaultAsync(\n                _subscriptionRepository.GetQueryableSet().Where(x => x.Id == pi.SubscriptionId.Value));\n\n            if (subscription == null)\n            {\n                throw new NotFoundException($\"Subscription '{pi.SubscriptionId}' was not found.\");\n            }\n\n            var oldPlanId = subscription.PlanId;\n            subscription.PlanId = plan.Id;\n            subscription.BillingCycle = pi.BillingCycle;\n            subscription.Status = SubscriptionStatus.Active;\n            subscription.StartDate = now;\n            subscription.EndDate = endDate;\n            subscription.NextBillingDate = endDate;\n\n            await _subscriptionRepository.UpdateAsync(subscription, ct);\n            changeType = pi.Purpose == PaymentPurpose.SubscriptionRenewal ? ChangeType.Reactivated : ChangeType.Upgraded;\n\n            var history = new SubscriptionHistory\n            {\n                Id = Guid.NewGuid(),\n                SubscriptionId = subscription.Id,\n                OldPlanId = oldPlanId,\n                NewPlanId = plan.Id,\n                ChangeType = changeType,\n                ChangeReason = $\"{changeType} via PayOS payment\",\n                EffectiveDate = now,\n            };\n            await _historyRepository.AddAsync(history, ct);\n        }\n        else\n        {\n            // Check if user already has any subscription\n            var existing = await _subscriptionRepository.FirstOrDefaultAsync(\n                _subscriptionRepository.GetQueryableSet()\n                    .Where(x => x.UserId == pi.UserId\n                        && (x.Status == SubscriptionStatus.Active || x.Status == SubscriptionStatus.Trial)));\n\n            if (existing != null)\n            {\n                var oldPlanId = existing.PlanId;\n                existing.PlanId = plan.Id;\n                existing.BillingCycle = pi.BillingCycle;\n                existing.Status = SubscriptionStatus.Active;\n                existing.StartDate = now;\n                existing.EndDate = endDate;\n                existing.NextBillingDate = endDate;\n                await _subscriptionRepository.UpdateAsync(existing, ct);\n                subscription = existing;\n                changeType = ChangeType.Upgraded;\n            }\n            else\n            {\n                // Create new subscription\n                subscription = new UserSubscription\n                {\n                    Id = Guid.NewGuid(),\n                    UserId = pi.UserId,\n                    PlanId = plan.Id,\n                    Status = SubscriptionStatus.Active,\n                    BillingCycle = pi.BillingCycle,\n                    StartDate = now,\n                    EndDate = endDate,\n                    NextBillingDate = endDate,\n                    AutoRenew = true,\n                };\n                await _subscriptionRepository.AddAsync(subscription, ct);\n                changeType = ChangeType.Created;\n            }\n\n            var history = new SubscriptionHistory\n            {\n                Id = Guid.NewGuid(),\n                SubscriptionId = subscription.Id,\n                OldPlanId = existing?.PlanId,\n                NewPlanId = plan.Id,\n                ChangeType = changeType,\n                ChangeReason = $\"{changeType} via PayOS payment\",\n                EffectiveDate = now,\n            };\n            await _historyRepository.AddAsync(history, ct);\n        }\n\n        return subscription;\n    }\n}"
    },

    "SyncPaymentFromPayOsCommand": {
      "file": "ClassifiedAds.Modules.Subscription/Commands/SyncPaymentFromPayOsCommand.cs",
      "description": "Command debug: đồng bộ payment từ PayOS nếu webhook thất bại",
      "code": "using ClassifiedAds.Application;\nusing ClassifiedAds.CrossCuttingConcerns.Exceptions;\nusing ClassifiedAds.Domain.Repositories;\nusing ClassifiedAds.Modules.Subscription.Entities;\nusing ClassifiedAds.Modules.Subscription.Models;\nusing ClassifiedAds.Modules.Subscription.Services;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Commands;\n\npublic class SyncPaymentFromPayOsCommand : ICommand\n{\n    public Guid UserId { get; set; }\n\n    public Guid IntentId { get; set; }\n\n    // Output\n    public string Status { get; set; }\n\n    public string PayOsStatus { get; set; }\n}\n\npublic class SyncPaymentFromPayOsCommandHandler : ICommandHandler<SyncPaymentFromPayOsCommand>\n{\n    private readonly IRepository<PaymentIntent, Guid> _paymentIntentRepository;\n    private readonly IPayOsService _payOsService;\n    private readonly Dispatcher _dispatcher;\n\n    public SyncPaymentFromPayOsCommandHandler(\n        IRepository<PaymentIntent, Guid> paymentIntentRepository,\n        IPayOsService payOsService,\n        Dispatcher dispatcher)\n    {\n        _paymentIntentRepository = paymentIntentRepository;\n        _payOsService = payOsService;\n        _dispatcher = dispatcher;\n    }\n\n    public async Task HandleAsync(SyncPaymentFromPayOsCommand command, CancellationToken cancellationToken = default)\n    {\n        var pi = await _paymentIntentRepository.FirstOrDefaultAsync(\n            _paymentIntentRepository.GetQueryableSet()\n                .Where(x => x.Id == command.IntentId && x.UserId == command.UserId));\n\n        if (pi == null)\n        {\n            throw new NotFoundException($\"Payment intent '{command.IntentId}' was not found.\");\n        }\n\n        if (pi.Status == PaymentIntentStatus.Succeeded)\n        {\n            command.Status = \"already_completed\";\n            return;\n        }\n\n        if (!pi.OrderCode.HasValue)\n        {\n            throw new ValidationException(\"Payment intent has no order code. No PayOS checkout was created.\");\n        }\n\n        // Query PayOS for actual payment status\n        var payosInfo = await _payOsService.GetPaymentInfoAsync(pi.OrderCode.Value, cancellationToken);\n        command.PayOsStatus = payosInfo.Status;\n\n        if (!IsSuccessStatus(payosInfo.Status))\n        {\n            command.Status = \"not_paid\";\n            return;\n        }\n\n        // Manually trigger webhook processing with 'manual-sync' signature\n        var webhookPayload = new PayOsWebhookPayload\n        {\n            Code = \"00\",\n            Desc = \"success\",\n            Success = true,\n            Data = new PayOsWebhookData\n            {\n                OrderCode = payosInfo.OrderCode,\n                Amount = payosInfo.Amount,\n                Description = $\"Manual sync for order {payosInfo.OrderCode}\",\n                Reference = payosInfo.Reference ?? payosInfo.OrderCode.ToString(),\n                TransactionDateTime = payosInfo.TransactionDateTime ?? DateTimeOffset.UtcNow.ToString(\"o\"),\n                PaymentLinkId = payosInfo.Reference,\n            },\n            Signature = \"manual-sync\",\n        };\n\n        var webhookCommand = new HandlePayOsWebhookCommand\n        {\n            Payload = webhookPayload,\n            RawBody = System.Text.Json.JsonSerializer.Serialize(webhookPayload),\n            SignatureHeader = null,\n        };\n\n        await _dispatcher.DispatchAsync(webhookCommand, cancellationToken);\n        command.Status = \"synced\";\n    }\n\n    private static bool IsSuccessStatus(string status)\n    {\n        if (string.IsNullOrWhiteSpace(status))\n        {\n            return false;\n        }\n\n        return status.Equals(\"PAID\", StringComparison.OrdinalIgnoreCase)\n            || status.Equals(\"SUCCESS\", StringComparison.OrdinalIgnoreCase)\n            || status.Equals(\"COMPLETED\", StringComparison.OrdinalIgnoreCase);\n    }\n}"
    }
  },

  "queries": {
    "GetPaymentIntentQuery": {
      "file": "ClassifiedAds.Modules.Subscription/Queries/GetPaymentIntentQuery.cs",
      "description": "Query lấy thông tin payment intent cho user",
      "code": "using ClassifiedAds.Application;\nusing ClassifiedAds.CrossCuttingConcerns.Exceptions;\nusing ClassifiedAds.Domain.Repositories;\nusing ClassifiedAds.Modules.Subscription.Entities;\nusing ClassifiedAds.Modules.Subscription.Models;\nusing Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Queries;\n\npublic class GetPaymentIntentQuery : IQuery<PaymentIntentModel>\n{\n    public Guid IntentId { get; set; }\n\n    public Guid? UserId { get; set; }\n\n    public bool ThrowNotFoundIfNull { get; set; }\n}\n\npublic class GetPaymentIntentQueryHandler : IQueryHandler<GetPaymentIntentQuery, PaymentIntentModel>\n{\n    private readonly IRepository<PaymentIntent, Guid> _repository;\n\n    public GetPaymentIntentQueryHandler(IRepository<PaymentIntent, Guid> repository)\n    {\n        _repository = repository;\n    }\n\n    public async Task<PaymentIntentModel> HandleAsync(GetPaymentIntentQuery query, CancellationToken cancellationToken = default)\n    {\n        var q = _repository.GetQueryableSet()\n            .Include(x => x.Plan)\n            .Where(x => x.Id == query.IntentId);\n\n        if (query.UserId.HasValue)\n        {\n            q = q.Where(x => x.UserId == query.UserId.Value);\n        }\n\n        var entity = await _repository.FirstOrDefaultAsync(q);\n\n        if (entity == null && query.ThrowNotFoundIfNull)\n        {\n            throw new NotFoundException($\"Payment intent '{query.IntentId}' was not found.\");\n        }\n\n        return entity?.ToModel();\n    }\n}"
    },

    "GetPaymentIntentByOrderCodeQuery": {
      "file": "ClassifiedAds.Modules.Subscription/Queries/GetPaymentIntentByOrderCodeQuery.cs",
      "description": "Query tìm payment intent theo PayOS order code (dùng cho return URL redirect)",
      "code": "using ClassifiedAds.Application;\nusing ClassifiedAds.Domain.Repositories;\nusing ClassifiedAds.Modules.Subscription.Entities;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Queries;\n\npublic class GetPaymentIntentByOrderCodeQuery : IQuery<PaymentIntent>\n{\n    public long OrderCode { get; set; }\n}\n\npublic class GetPaymentIntentByOrderCodeQueryHandler : IQueryHandler<GetPaymentIntentByOrderCodeQuery, PaymentIntent>\n{\n    private readonly IRepository<PaymentIntent, Guid> _repository;\n\n    public GetPaymentIntentByOrderCodeQueryHandler(IRepository<PaymentIntent, Guid> repository)\n    {\n        _repository = repository;\n    }\n\n    public async Task<PaymentIntent> HandleAsync(GetPaymentIntentByOrderCodeQuery query, CancellationToken cancellationToken = default)\n    {\n        return await _repository.FirstOrDefaultAsync(\n            _repository.GetQueryableSet().Where(x => x.OrderCode == query.OrderCode));\n    }\n}"
    }
  },

  "controller": {
    "PaymentsController": {
      "file": "ClassifiedAds.Modules.Subscription/Controllers/PaymentsController.cs",
      "description": "API Controller cho payment endpoints. Tuân theo pattern của dự án: inject Dispatcher, gọi Commands/Queries.",
      "route": "api/payments",
      "code": "using ClassifiedAds.Application;\nusing ClassifiedAds.Modules.Subscription.Authorization;\nusing ClassifiedAds.Modules.Subscription.Commands;\nusing ClassifiedAds.Modules.Subscription.ConfigurationOptions;\nusing ClassifiedAds.Modules.Subscription.Entities;\nusing ClassifiedAds.Modules.Subscription.Models;\nusing ClassifiedAds.Modules.Subscription.Queries;\nusing ClassifiedAds.Modules.Subscription.RateLimiterPolicies;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.RateLimiting;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ClassifiedAds.Modules.Subscription.Controllers;\n\n[EnableRateLimiting(RateLimiterPolicyNames.DefaultPolicy)]\n[Authorize]\n[Produces(\"application/json\")]\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class PaymentsController : ControllerBase\n{\n    private readonly Dispatcher _dispatcher;\n    private readonly ILogger<PaymentsController> _logger;\n    private readonly PayOsOptions _payOsOptions;\n\n    public PaymentsController(\n        Dispatcher dispatcher,\n        ILogger<PaymentsController> logger,\n        IOptions<PayOsOptions> payOsOptions)\n    {\n        _dispatcher = dispatcher;\n        _logger = logger;\n        _payOsOptions = payOsOptions?.Value ?? new PayOsOptions();\n    }\n\n    /// <summary>\n    /// Mua hoặc upgrade subscription plan.\n    /// Free plan → kích hoạt ngay. Paid plan → tạo PaymentIntent.\n    /// </summary>\n    [Authorize(Permissions.CreateSubscriptionPayment)]\n    [HttpPost(\"subscribe/{planId:guid}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status400BadRequest)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    public async Task<ActionResult<SubscriptionPurchaseResultModel>> Subscribe(\n        Guid planId,\n        [FromBody] CreateSubscriptionPaymentModel model,\n        CancellationToken ct)\n    {\n        var userId = GetCurrentUserId();\n        var command = new CreateSubscriptionPaymentCommand\n        {\n            UserId = userId,\n            PlanId = planId,\n            Model = model,\n        };\n\n        await _dispatcher.DispatchAsync(command, ct);\n        return Ok(command.Result);\n    }\n\n    /// <summary>\n    /// Lấy thông tin payment intent.\n    /// </summary>\n    [Authorize(Permissions.GetPaymentIntent)]\n    [HttpGet(\"{intentId:guid}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    public async Task<ActionResult<PaymentIntentModel>> Get(Guid intentId, CancellationToken ct)\n    {\n        var userId = GetCurrentUserId();\n        var result = await _dispatcher.DispatchAsync(new GetPaymentIntentQuery\n        {\n            IntentId = intentId,\n            UserId = userId,\n            ThrowNotFoundIfNull = true,\n        }, ct);\n\n        return Ok(result);\n    }\n\n    /// <summary>\n    /// Tạo PayOS checkout URL cho payment intent.\n    /// </summary>\n    [Authorize(Permissions.CreatePayOsCheckout)]\n    [HttpPost(\"payos/create\")]\n    [Consumes(\"application/json\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status400BadRequest)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    public async Task<ActionResult<PayOsCheckoutResponseModel>> CreatePayOsCheckout(\n        [FromBody] PayOsCheckoutRequestModel request,\n        CancellationToken ct)\n    {\n        var userId = GetCurrentUserId();\n        var command = new CreatePayOsCheckoutCommand\n        {\n            UserId = userId,\n            IntentId = request.IntentId,\n            ReturnUrl = request.ReturnUrl,\n        };\n\n        await _dispatcher.DispatchAsync(command, ct);\n        return Ok(command.Result);\n    }\n\n    /// <summary>\n    /// PayOS webhook - nhận thông báo trạng thái thanh toán.\n    /// LUÔN trả 200 OK để tránh PayOS retry.\n    /// </summary>\n    [AllowAnonymous]\n    [IgnoreAntiforgeryToken]\n    [HttpPost(\"payos/webhook\")]\n    public async Task<ActionResult> PayOsWebhook(CancellationToken ct)\n    {\n        string rawBody;\n        using (var reader = new StreamReader(Request.Body, Encoding.UTF8, leaveOpen: true))\n        {\n            rawBody = await reader.ReadToEndAsync(ct).ConfigureAwait(false);\n        }\n\n        _logger.LogInformation(\"PayOS webhook received. Body={Body}\", rawBody);\n\n        // Empty body = test webhook\n        if (string.IsNullOrWhiteSpace(rawBody) || rawBody.Trim() == \"{}\" || rawBody.Trim() == \"[]\")\n        {\n            return Ok(new { status = \"ok\", message = \"Test webhook received successfully\" });\n        }\n\n        PayOsWebhookPayload payload;\n        try\n        {\n            payload = JsonSerializer.Deserialize<PayOsWebhookPayload>(rawBody, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n        }\n        catch (JsonException ex)\n        {\n            _logger.LogWarning(ex, \"Failed to deserialize PayOS webhook.\");\n            return Ok(new { status = \"error\", message = \"Invalid JSON format\" });\n        }\n\n        if (payload?.Data is null)\n        {\n            return Ok(new { status = \"ok\", message = \"Test webhook received\" });\n        }\n\n        string signatureHeader = null;\n        if (Request.Headers.TryGetValue(\"x-signature\", out var sig))\n        {\n            signatureHeader = sig.ToString();\n        }\n\n        try\n        {\n            var command = new HandlePayOsWebhookCommand\n            {\n                Payload = payload,\n                RawBody = rawBody,\n                SignatureHeader = signatureHeader,\n            };\n\n            await _dispatcher.DispatchAsync(command, ct);\n\n            var statusLabel = command.Outcome == PayOsWebhookOutcome.Ignored ? \"ignored\" : \"ok\";\n            return Ok(new { status = statusLabel });\n        }\n        catch (Exception ex)\n        {\n            _logger.LogWarning(ex, \"PayOS webhook processing failed.\");\n            return Ok(new { status = \"error\", error = ex.Message });\n        }\n    }\n\n    /// <summary>\n    /// PayOS return URL - redirect user tới frontend sau thanh toán.\n    /// </summary>\n    [AllowAnonymous]\n    [HttpGet(\"payos/return\")]\n    public async Task<ActionResult> PayOsReturn(CancellationToken ct)\n    {\n        var status = Request.Query[\"status\"].ToString();\n        var orderCode = Request.Query[\"orderCode\"].ToString();\n\n        if (IsSuccessStatus(status) && long.TryParse(orderCode, out var orderCodeValue))\n        {\n            var pi = await _dispatcher.DispatchAsync(new GetPaymentIntentByOrderCodeQuery\n            {\n                OrderCode = orderCodeValue,\n            }, ct);\n\n            if (pi != null)\n            {\n                return Redirect(BuildResultUrl(\"success\", pi.Id));\n            }\n        }\n\n        return Redirect(BuildResultUrl(\"failed\", null));\n    }\n\n    /// <summary>\n    /// Debug: kiểm tra trạng thái payment intent.\n    /// </summary>\n    [Authorize(Permissions.GetPaymentIntent)]\n    [HttpPost(\"debug/check-payment/{intentId:guid}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    public async Task<ActionResult> CheckPaymentStatus(Guid intentId, CancellationToken ct)\n    {\n        var userId = GetCurrentUserId();\n        var intent = await _dispatcher.DispatchAsync(new GetPaymentIntentQuery\n        {\n            IntentId = intentId,\n            UserId = userId,\n            ThrowNotFoundIfNull = true,\n        }, ct);\n\n        return Ok(new\n        {\n            intentId = intent.Id,\n            status = intent.Status,\n            orderCode = intent.OrderCode,\n            amount = intent.Amount,\n            purpose = intent.Purpose,\n            createdAt = intent.CreatedDateTime,\n        });\n    }\n\n    /// <summary>\n    /// Debug: đồng bộ payment từ PayOS nếu webhook thất bại.\n    /// </summary>\n    [Authorize(Permissions.SyncPayment)]\n    [HttpPost(\"debug/sync-payment/{intentId:guid}\")]\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    public async Task<ActionResult> SyncPaymentFromPayOs(Guid intentId, CancellationToken ct)\n    {\n        var userId = GetCurrentUserId();\n        var command = new SyncPaymentFromPayOsCommand\n        {\n            UserId = userId,\n            IntentId = intentId,\n        };\n\n        await _dispatcher.DispatchAsync(command, ct);\n\n        return Ok(new\n        {\n            status = command.Status,\n            payOsStatus = command.PayOsStatus,\n        });\n    }\n\n    // === Private Helpers ===\n\n    private Guid GetCurrentUserId()\n    {\n        var userIdClaim = User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)\n            ?? User.FindFirst(\"sub\")\n            ?? User.FindFirst(\"uid\");\n\n        if (userIdClaim == null || !Guid.TryParse(userIdClaim.Value, out var userId))\n        {\n            throw new CrossCuttingConcerns.Exceptions.ValidationException(\"User identity is required.\");\n        }\n\n        return userId;\n    }\n\n    private static bool IsSuccessStatus(string status)\n    {\n        if (string.IsNullOrWhiteSpace(status))\n        {\n            return false;\n        }\n\n        return status.Equals(\"PAID\", StringComparison.OrdinalIgnoreCase)\n            || status.Equals(\"SUCCESS\", StringComparison.OrdinalIgnoreCase)\n            || status.Equals(\"COMPLETED\", StringComparison.OrdinalIgnoreCase);\n    }\n\n    private string BuildResultUrl(string status, Guid? intentId)\n    {\n        var query = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)\n        {\n            [\"status\"] = status,\n        };\n\n        if (intentId.HasValue)\n        {\n            query[\"intentId\"] = intentId.Value.ToString();\n        }\n\n        var basePath = \"/payment/result\";\n        var frontendBase = _payOsOptions.FrontendBaseUrl?.Trim();\n\n        if (!string.IsNullOrWhiteSpace(frontendBase) && Uri.TryCreate(frontendBase, UriKind.Absolute, out var baseUri))\n        {\n            var targetUri = new Uri(baseUri, basePath);\n            return QueryHelpers.AddQueryString(targetUri.ToString(), query);\n        }\n\n        return QueryHelpers.AddQueryString(basePath, query);\n    }\n}",
      "endpoints": [
        {
          "method": "POST",
          "path": "api/payments/subscribe/{planId:guid}",
          "handler": "Subscribe",
          "description": "Mua/upgrade subscription plan. Free → kích hoạt ngay. Paid → tạo PaymentIntent.",
          "auth": "Authorize(Permissions.CreateSubscriptionPayment)",
          "requestBody": "CreateSubscriptionPaymentModel { BillingCycle }",
          "responses": {
            "200": "SubscriptionPurchaseResultModel { requiresPayment, paymentIntentId, subscription }",
            "400": "Validation error",
            "404": "Plan not found"
          }
        },
        {
          "method": "GET",
          "path": "api/payments/{intentId:guid}",
          "handler": "Get",
          "description": "Lấy thông tin payment intent",
          "auth": "Authorize(Permissions.GetPaymentIntent)",
          "responses": { "200": "PaymentIntentModel", "404": "Not found" }
        },
        {
          "method": "POST",
          "path": "api/payments/payos/create",
          "handler": "CreatePayOsCheckout",
          "description": "Tạo PayOS checkout URL cho payment intent pending",
          "auth": "Authorize(Permissions.CreatePayOsCheckout)",
          "requestBody": "PayOsCheckoutRequestModel { IntentId, ReturnUrl? }",
          "responses": {
            "200": "PayOsCheckoutResponseModel { checkoutUrl, orderCode }",
            "400": "Validation (expired/wrong status)",
            "404": "Intent not found"
          }
        },
        {
          "method": "POST",
          "path": "api/payments/payos/webhook",
          "handler": "PayOsWebhook",
          "description": "PayOS webhook - nhận thông báo trạng thái thanh toán",
          "auth": "AllowAnonymous",
          "important": "LUÔN trả 200 OK để tránh PayOS retry. Errors chỉ log.",
          "responses": { "200": "{ status: 'ok'|'ignored'|'error' }" }
        },
        {
          "method": "GET",
          "path": "api/payments/payos/return",
          "handler": "PayOsReturn",
          "description": "PayOS return URL - redirect user tới frontend",
          "auth": "AllowAnonymous",
          "queryParams": { "status": "PAID|SUCCESS|COMPLETED", "orderCode": "PayOS order code" },
          "responses": { "302": "Redirect tới /payment/result?status=success&intentId={guid}" }
        },
        {
          "method": "POST",
          "path": "api/payments/debug/check-payment/{intentId:guid}",
          "handler": "CheckPaymentStatus",
          "description": "Debug: kiểm tra trạng thái payment intent",
          "auth": "Authorize(Permissions.GetPaymentIntent)"
        },
        {
          "method": "POST",
          "path": "api/payments/debug/sync-payment/{intentId:guid}",
          "handler": "SyncPaymentFromPayOs",
          "description": "Debug: đồng bộ payment từ PayOS nếu webhook thất bại",
          "auth": "Authorize(Permissions.SyncPayment)"
        }
      ]
    }
  },

  "apiFlowExamples": {
    "subscriptionPurchaseViaPaOS": {
      "description": "Complete flow: User mua subscription plan Paid → PayOS payment",
      "steps": [
        {
          "step": 1,
          "action": "POST /api/payments/subscribe/{planId}",
          "headers": { "Authorization": "Bearer {jwt}" },
          "body": { "billingCycle": "Monthly" },
          "response": {
            "status": 200,
            "body": { "requiresPayment": true, "paymentIntentId": "abc123-...", "subscription": null }
          }
        },
        {
          "step": 2,
          "action": "POST /api/payments/payos/create",
          "body": { "intentId": "abc123-...", "returnUrl": "https://frontend.com/payment/result" },
          "response": {
            "status": 200,
            "body": { "checkoutUrl": "https://pay.payos.vn/web/...", "orderCode": 123456789012345 }
          }
        },
        {
          "step": 3,
          "action": "User mở checkoutUrl trong browser → thanh toán qua QR/chuyển khoản ngân hàng"
        },
        {
          "step": 4,
          "action": "PayOS gửi POST /api/payments/payos/webhook",
          "body": {
            "code": "00",
            "desc": "success",
            "success": true,
            "data": {
              "orderCode": 123456789012345,
              "amount": 199000,
              "description": "Pro#345678",
              "reference": "FT12345"
            },
            "signature": "hmac-sha256-hex"
          },
          "serverSideEffects": [
            "PaymentTransaction created (Provider=PAYOS, Status=Succeeded)",
            "UserSubscription created/updated (Status=Active, EndDate set)",
            "SubscriptionHistory created (ChangeType=Created/Upgraded)",
            "PaymentIntent status → Succeeded"
          ]
        },
        {
          "step": 5,
          "action": "User redirect tới GET /api/payments/payos/return?status=PAID&orderCode=123456789012345",
          "response": "302 Redirect → https://frontend.com/payment/result?status=success&intentId=abc123-..."
        }
      ]
    },
    "freeSubscription": {
      "description": "User đăng ký Free plan (không cần thanh toán)",
      "steps": [
        {
          "step": 1,
          "action": "POST /api/payments/subscribe/{freePlanId}",
          "body": { "billingCycle": "Monthly" },
          "response": {
            "status": 200,
            "body": {
              "requiresPayment": false,
              "paymentIntentId": null,
              "subscription": {
                "id": "guid",
                "planId": "guid",
                "status": "Active",
                "startDate": "2026-02-08",
                "endDate": null
              }
            }
          },
          "serverSideEffects": [
            "UserSubscription created (Status=Active)",
            "SubscriptionHistory created (ChangeType=Created)"
          ]
        }
      ]
    },
    "manualSync": {
      "description": "Debug: Đồng bộ thanh toán khi webhook thất bại",
      "steps": [
        {
          "step": 1,
          "action": "POST /api/payments/debug/sync-payment/{intentId}",
          "response": { "status": 200, "body": { "status": "synced", "payOsStatus": "PAID" } },
          "note": "Gọi PayOS API để kiểm tra, sau đó tạo mock webhook payload để xử lý"
        }
      ]
    }
  },

  "implementationChecklist": [
    "1. Tạo file Entities/PaymentIntent.cs (entity + enums)",
    "2. Cập nhật Entities/PaymentTransaction.cs (thêm PaymentIntentId, Provider, ProviderRef)",
    "3. Tạo file DbConfigurations/PaymentIntentConfiguration.cs",
    "4. Cập nhật DbConfigurations/PaymentTransactionConfiguration.cs",
    "5. Cập nhật Persistence/SubscriptionDbContext.cs (thêm DbSet<PaymentIntent>)",
    "6. Tạo file ConfigurationOptions/PayOsOptions.cs",
    "7. Cập nhật ConfigurationOptions/SubscriptionModuleOptions.cs (thêm PayOsOptions)",
    "8. Tạo tất cả Models (PaymentIntentModel, SubscriptionPurchaseResultModel, PayOsModels, etc.)",
    "9. Tạo PaymentIntentModelMappingConfiguration.cs",
    "10. Cập nhật PaymentTransactionModel và AddPaymentTransactionModel (thêm new fields)",
    "11. Tạo Services/IPayOsService.cs và Services/PayOsService.cs",
    "12. Tạo Commands (CreateSubscriptionPayment, CreatePayOsCheckout, HandlePayOsWebhook, SyncPaymentFromPayOs)",
    "13. Tạo Queries (GetPaymentIntent, GetPaymentIntentByOrderCode)",
    "14. Tạo Controllers/PaymentsController.cs",
    "15. Cập nhật Authorization/Permissions.cs",
    "16. Cập nhật ServiceCollectionExtensions.cs (DI registrations)",
    "17. Cập nhật appsettings.json / .env với PayOS configuration",
    "18. Tạo EF Core migration",
    "19. Test webhook endpoint với PayOS sandbox"
  ]
}
